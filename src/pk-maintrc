#
#! \file    ./src/pk-maintrc
#! \author  Jiří Kučera, <jkucera AT redhat.com>
#! \stamp   2018-01-01 02:20:19 (UTC+01:00, DST+00:00)
#! \project pkgtools: Tools for Maintaining Fedora Packages
#! \license MIT (see ./LICENSE)
#! \version See ./VERSION
#! \fdesc   pk-maint configuration.
#

require_command wc
require_command ls
require_command mkdir
require_command cp
require_command mv
require_command rm
require_command tar
require_command gzip
require_command bzip2
require_command fedpkg

###############################################################################
# User configuration
###############################################################################

##
# User settings.
setvar USER_NAME ''
setvar USER_LOGIN ''
setvar USER_EMAIL1 ''
setvar USER_EMAIL2 ''
setvar USER_EMAIL3 ''
setvar USER_EMAIL4 ''
setvar USER_EMAIL5 ''

###############################################################################
# `new-file' command configuration
###############################################################################

##
# newfile_at_guess_template_begin $1 $2
#
#   $1 - variable to store guessed template
#   $2 - file name
#
# Guess a template for $2. Can be overriden by the user.
function newfile_at_guess_template_begin() {
  eval "$1=\"\""
}

##
# newfile_on_guess_template_fail $1 $2
#
#   $1 - variable to store guessed template
#   $2 - file name
#
# Guess a template for $2 if the previous methods have failed or issue an error.
# Can be overriden by the user.
function newfile_on_guess_template_fail() {
  eval "$1=\"\""
}

##
# newfile_at_guess_interpreter_begin $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Determine interpreter at early phase of newfile_guess_interpreter. Can be
# overriden by the user.
function newfile_at_guess_interpreter_begin() {
  echo ""
}

##
# newfile_on_guess_interpreter_fail $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Determine interpreter or raise an error if other attempts fails. Can be
# overriden by the user.
function newfile_on_guess_interpreter_fail() {
  echo "/usr/bin/false"
}

##
# newfile_guess_interpreter $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Determine interpreter for $3.
function newfile_guess_interpreter() {
  local T

  T=$(newfile_at_guess_interpreter_begin "$@")
  if [ "$T" ]; then
    echo "$T"
  else
    case "$1" in
      sh | SH) echo "/bin/sh" ;;
      bash | BASH) echo "/bin/bash" ;;
      py | PY | python | PYTHON) echo "/usr/bin/python" ;;
      *) newfile_on_guess_interpreter_fail "$@"
    esac
  fi
}

##
# newfile_guess_file_path $1 $2 $3
#
#   $1 - template type
#   $2 - project root file or directory (i.e. Maintfile, .git)
#   $3 - file
#
# Determine path to $3 relative to the project root file or directory location.
# Can be overriden by the user.
function newfile_guess_file_path() {
  local D
  local R

  D=$(pwd)
  R=$(search_upwards "$3" "$2")
  if [ -z "$R" ]; then
    echo "./$3"
  else
    R=$(dirname "$R")
    R=$(compute_relpath "$D/$3" "$R")
    echo "./$R"
  fi
}

##
# newfile_guess_author_name $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Determine the author's name. Can be overriden by the user.
function newfile_guess_author_name() {
  if [ "${ProjectVars[AUTHOR_NAME]}" ]; then
    echo "${ProjectVars[AUTHOR_NAME]}"
  elif [ "${ProjectVars[USER_NAME]}" ]; then
    echo "${ProjectVars[USER_NAME]}"
  else
    echo "Name Surname"
  fi
}

##
# newfile_guess_author_name1 $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Determine the name of the 1st author. Can be overriden by the user.
function newfile_guess_author_name1() {
  if [ "${ProjectVars[AUTHOR1_NAME]}" ]; then
    echo "${ProjectVars[AUTHOR1_NAME]}"
  elif [ "${ProjectVars[USER_NAME]}" ]; then
    echo "${ProjectVars[USER_NAME]}"
  else
    echo "Name Surname"
  fi
}

##
# newfile_guess_author_name2 $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Determine the name of the 2nd author. Can be overriden by the user.
function newfile_guess_author_name2() {
  if [ "${ProjectVars[AUTHOR2_NAME]}" ]; then
    echo "${ProjectVars[AUTHOR2_NAME]}"
  else
    echo "Name Surname"
  fi
}

##
# newfile_guess_author_name3 $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Determine the name of the 3rd author. Can be overriden by the user.
function newfile_guess_author_name3() {
  if [ "${ProjectVars[AUTHOR3_NAME]}" ]; then
    echo "${ProjectVars[AUTHOR3_NAME]}"
  else
    echo "Name Surname"
  fi
}

##
# newfile_guess_author_name4 $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Determine the name of the 4th author. Can be overriden by the user.
function newfile_guess_author_name4() {
  if [ "${ProjectVars[AUTHOR4_NAME]}" ]; then
    echo "${ProjectVars[AUTHOR4_NAME]}"
  else
    echo "Name Surname"
  fi
}

##
# newfile_guess_author_name5 $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Determine the name of the 5th author. Can be overriden by the user.
function newfile_guess_author_name5() {
  if [ "${ProjectVars[AUTHOR5_NAME]}" ]; then
    echo "${ProjectVars[AUTHOR5_NAME]}"
  else
    echo "Name Surname"
  fi
}

##
# newfile_guess_author_email $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Determine author's email address. Can be overriden by the user.
function newfile_guess_author_email() {
  if [ "${ProjectVars[AUTHOR_EMAIL]}" ]; then
    echo "${ProjectVars[AUTHOR_EMAIL]}"
  elif [ "${ProjectVars[USER_EMAIL1]}" ]; then
    echo "${ProjectVars[USER_EMAIL1]}"
  else
    echo "login AT domain.com"
  fi
}

##
# newfile_guess_author_email1 $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Determine an email address of the 1st author. Can be overriden by the user.
function newfile_guess_author_email1() {
  if [ "${ProjectVars[AUTHOR1_EMAIL]}" ]; then
    echo "${ProjectVars[AUTHOR1_EMAIL]}"
  elif [ "${ProjectVars[USER_EMAIL1]}" ]; then
    echo "${ProjectVars[USER_EMAIL1]}"
  else
    echo "login AT domain.com"
  fi
}

##
# newfile_guess_author_email2 $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Determine an email address of the 2nd author. Can be overriden by the user.
function newfile_guess_author_email2() {
  if [ "${ProjectVars[AUTHOR2_EMAIL]}" ]; then
    echo "${ProjectVars[AUTHOR2_EMAIL]}"
  else
    echo "login AT domain.com"
  fi
}

##
# newfile_guess_author_email3 $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Determine an email address of the 3rd author. Can be overriden by the user.
function newfile_guess_author_email3() {
  if [ "${ProjectVars[AUTHOR3_EMAIL]}" ]; then
    echo "${ProjectVars[AUTHOR3_EMAIL]}"
  else
    echo "login AT domain.com"
  fi
}

##
# newfile_guess_author_email4 $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Determine an email address of the 4th author. Can be overriden by the user.
function newfile_guess_author_email4() {
  if [ "${ProjectVars[AUTHOR4_EMAIL]}" ]; then
    echo "${ProjectVars[AUTHOR4_EMAIL]}"
  else
    echo "login AT domain.com"
  fi
}

##
# newfile_guess_author_email5 $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Determine an email address of the 5th author. Can be overriden by the user.
function newfile_guess_author_email5() {
  if [ "${ProjectVars[AUTHOR5_EMAIL]}" ]; then
    echo "${ProjectVars[AUTHOR5_EMAIL]}"
  else
    echo "login AT domain.com"
  fi
}

##
# newfile_guess_stamp $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Get the time date stamp string of $3. Can be overriden by the user.
function newfile_guess_stamp() {
  local F

  F=$(eval_template NEWFILE_STAMP_FORMAT)
  sh $PKM_PROG stamp "--file=$3" "--format=$F"
}

##
# newfile_guess_project_desc $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Get the project description. Can be overriden by the user.
function newfile_guess_project_desc() {
  if [ "${ProjectVars[PROJECT]}" ]; then
    echo "${ProjectVars[PROJECT]}"
  else
    echo "???"
  fi
}

##
# newfile_guess_license $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Get the project license. Can be overriden by the user.
function newfile_guess_license() {
  if [ "${ProjectVars[LICENSE]}" ]; then
    echo "${ProjectVars[LICENSE]}"
  else
    echo "???"
  fi
}

##
# newfile_guess_version $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Get the project version. Can be overriden by the user.
function newfile_guess_version() {
  if [ "${ProjectVars[VERSION]}" ]; then
    echo "${ProjectVars[VERSION]}"
  else
    echo "???"
  fi
}

##
# newfile_guess_file_desc $1 $2 $3
#
#   $1 - template type
#   $2 - project root
#   $3 - file
#
# Get the file description. Can be overriden by the user.
function newfile_guess_file_desc() {
  if [ "$NEWFILEOPT_FDESC" ]; then
    echo "$NEWFILEOPT_FDESC"
  else
    echo "???"
  fi
}

##
# newfile_gen_header_template $1 $2 ... $n
#
#   $1, $2, ..., $n - commands with their arguments
#
# Assemble file header template and send it to stdout. The meaning of commands
# together with their arguments is following:
#
#   -b        emit shebang line
#   -u X      emit a line of the length 79 characters starting with X and ending
#             with -*- coding: utf-8 -*-
#   -c X      emit X
#   -l X Y    emit field line beginning with X and ending with Y
#   -F X      emit path to file line beginning with X
#   -A X      emit author line beginning with X
#   -T X      emit time date stamp line beginning with X
#   -P X      emit project description line beginning with X
#   -L X      emit project license line beginning with X
#   -V X      emit project version line beginning with X
#   -B X      emit file description (brief) line beginning with X
#   -H X      emit all field lines, each line is starting with X
#
function newfile_gen_header_template() {
  while [ $# -gt 0 ]; do
    case "$1" in
      -b)
        echo "#!@INTERPRETER"
        shift
        ;;
      -u)
        text_to_right "$2" "-*- coding: utf-8 -*-" 79
        shift 2
        ;;
      -c)
        echo "$2"
        shift 2
        ;;
      -l)
        echo "$2!          $3"
        shift 3
        ;;
      -F)
        echo "$2! \\\\file    @FILE"
        shift 2
        ;;
      -A)
        echo "$2! \\\\author  @AUTHOR"
        shift 2
        ;;
      -T)
        echo "$2! \\\\stamp   @STAMP"
        shift 2
        ;;
      -P)
        echo "$2! \\\\project @PROJECT_DESC"
        shift 2
        ;;
      -L)
        echo "$2! \\\\license @LICENSE"
        shift 2
        ;;
      -V)
        echo "$2! \\\\version @VERSION"
        shift 2
        ;;
      -B)
        echo "$2! \\\\fdesc   @FILE_DESC"
        shift 2
        ;;
      -H)
        echo "$2! \\\\file    @FILE_PATH"
        echo "$2! \\\\author  @AUTHOR"
        echo "$2! \\\\stamp   @STAMP"
        echo "$2! \\\\project @PROJECT_DESC"
        echo "$2! \\\\license @LICENSE"
        echo "$2! \\\\version @VERSION"
        echo "$2! \\\\fdesc   @FILE_DESC"
        shift 2
        ;;
    esac
  done
}

##
# newfile_template_args
#
# Return additional template arguments. Can be overriden by the user.
function newfile_template_args() {
  echo -n "AUTHOR=NEWFILE_AUTHOR_TEMPLATE"
  echo -n " AUTHOR1=NEWFILE_AUTHOR1_TEMPLATE"
  echo -n " AUTHOR2=NEWFILE_AUTHOR2_TEMPLATE"
  echo -n " AUTHOR3=NEWFILE_AUTHOR3_TEMPLATE"
  echo -n " AUTHOR4=NEWFILE_AUTHOR4_TEMPLATE"
  echo    " AUTHOR5=NEWFILE_AUTHOR5_TEMPLATE"
}

config new-file INTERPRETER "\$(newfile_guess_interpreter \"\$T\" \"\$R\" \"\$F\")"
config new-file FILE_PATH "\$(newfile_guess_file_path \"\$T\" \"\$R\" \"\$F\")"

template NEWFILE_AUTHOR_TEMPLATE "@AUTHOR_NAME, <@AUTHOR_EMAIL>"
template NEWFILE_AUTHOR1_TEMPLATE "@AUTHOR1_NAME, <@AUTHOR1_EMAIL>"
template NEWFILE_AUTHOR2_TEMPLATE "@AUTHOR2_NAME, <@AUTHOR2_EMAIL>"
template NEWFILE_AUTHOR3_TEMPLATE "@AUTHOR3_NAME, <@AUTHOR3_EMAIL>"
template NEWFILE_AUTHOR4_TEMPLATE "@AUTHOR4_NAME, <@AUTHOR4_EMAIL>"
template NEWFILE_AUTHOR5_TEMPLATE "@AUTHOR5_NAME, <@AUTHOR5_EMAIL>"
template NEWFILE_AUTHORS_TEMPLATE "See ./AUTHORS"

config new-file AUTHOR_NAME "\$(newfile_guess_author_name \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR_EMAIL "\$(newfile_guess_author_email \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR1_NAME "\$(newfile_guess_author_name1 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR1_EMAIL "\$(newfile_guess_author_email1 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR2_NAME "\$(newfile_guess_author_name2 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR2_EMAIL "\$(newfile_guess_author_email2 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR3_NAME "\$(newfile_guess_author_name3 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR3_EMAIL "\$(newfile_guess_author_email3 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR4_NAME "\$(newfile_guess_author_name4 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR4_EMAIL "\$(newfile_guess_author_email4 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR5_NAME "\$(newfile_guess_author_name5 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR5_EMAIL "\$(newfile_guess_author_email5 \"\$T\" \"\$R\" \"\$F\")"

config new-file DATE_FMT "%Y-%m-%d"
config new-file TIME_FMT "%H:%M:%S"
config new-file UTC_FMT "%!0z%!1z:%!2z"
config new-file DST_FMT "%*0z%*1z:%*2z"

template NEWFILE_STAMP_FORMAT "@DATE_FMT @TIME_FMT (UTC@UTC_FMT, DST@DST_FMT)"

config new-file STAMP "\$(newfile_guess_stamp \"\$T\" \"\$R\" \"\$F\")"
config new-file PROJECT_DESC "\$(newfile_guess_project_desc \"\$T\" \"\$R\" \"\$F\")"
config new-file LICENSE "\$(newfile_guess_license \"\$T\" \"\$R\" \"\$F\")"
config new-file VERSION "\$(newfile_guess_version \"\$T\" \"\$R\" \"\$F\")"
config new-file FILE_DESC "\$(newfile_guess_file_desc \"\$T\" \"\$R\" \"\$F\")"

template NEWFILE_C_HEADER_TEMPLATE \
  "$(newfile_gen_header_template -c '/*' -H ' *' -c ' *' -c ' */')" \
  $(newfile_template_args)
template NEWFILE_MAKEFILE_HEADER_TEMPLATE \
  "$(newfile_gen_header_template -c '#' -H '#' -c '#')" \
  $(newfile_template_args)

template NEWFILE_PLAIN_TEMPLATE ""

template NEWFILE_C_TEMPLATE "\
@HEADER
" HEADER=NEWFILE_C_HEADER_TEMPLATE

template NEWFILE_MAKEFILE_TEMPLATE "\
@HEADER
" HEADER=NEWFILE_MAKEFILE_HEADER_TEMPLATE

template NEWFILE_MAINTFILE_TEMPLATE "\
@HEADER

# Project variables:
setvar PROJECT '\"''\"'
setvar AUTHOR_NAME '\"''\"'
setvar AUTHOR_EMAIL '\"''\"'
setvar LICENSE '\"''\"'
setvar VERSION '\"''\"'

# Project maintaining tasks:
" HEADER=NEWFILE_MAKEFILE_HEADER_TEMPLATE

###############################################################################
# `Maintfile' library
###############################################################################

##
# arcrmext $1
#
#   $1 - tarball name
#
# Remove $1's extension.
function arcrmext() {
  local T

  T="$1"
  case "$T" in
    *.tar.*)
      echo "${T%.tar.*}"
      ;;
    *)
      echo "${T%.*}"
  esac
}

##
# nlines $1
#
#   $1 - text
#
# Count lines in $1.
function nlines() {
  echo "$1" | wc -l
}

##
# dir_read $1 $2
#
#   $1 - container (associative array)
#   $2 - directory
#
# Save all item names in $2 to $1.
function dir_read() {
  for f in $(ls -a1 "$2"); do
    eval "$1[$f]=1"
  done
}

##
# dir_diff $1 $2 $3
#
#   $1 - container (associative array)
#   $2 - directory
#   $3 - result
#
# Record all item names (one per line) from $2 that are not recorded in $1 to
# $3.
function dir_diff() {
  for f in $(ls -a1 "$2"); do
    eval "\
      if [ -z \"\${$1[$f]}\" ]; then
        if [ -z \"\${$3}\" ]; then
          $3=\"$f\"
        else
          $3=\"\${$3}\${nl_sep}$f\"
        fi
      fi
    "
  done
}

##
# ensure_dir $1
#
#   $1 - directory name
#
# Test if $1 exists. If not, create it. If $1 is a file, fail.
function ensure_dir() {
  [ -f "$1" ] && error "$FUNCNAME: $1 is a file"
  [ -d "$1" ] || mkdir "$1"
}

##
# unpack $1
#
#   $1 - archive
#
# Unpack $1 to the current working directory.
function unpack() {
  case "$1" in
    *.tar.gz | *.tgz)
      gzip -dc "$1" | tar -xvvof -
      ;;
    *.tar.bz2)
      bzip2 -dc "$1" | tar -xvvof -
      ;;
    *)
      error "$FUNCNAME: I don't know how to unpack '$1'"
  esac
}

##
# relpath_of $1
#
#   $1 - file name
#
# Return a path to $1 relative to the project root directory. If $1 contain
# LFs, first line is taken as an argument.
function relpath_of() {
  local R
  local F

  [ -z "$1" ] && error "$FUNCNAME: no file given"
  F=$(echo "$1" | head -n 1)
  [ -z "$F" ] && error "$FUNCNAME: empty file name"
  case "$F" in
    /*) : ;;
    *) F="$(pwd)/$F" ;;
  esac
  R=$(dirname "$PKM_MAINTFILE")
  compute_relpath "$F" "$R"
}

# Python is more safe then sed in some circumstances:
header_updater_='
import sys

bye = sys.exit
argv = sys.argv[1:]

def error(msg, *args):
    sys.stderr.write("header_updater: %s\n" % (msg % args))
    bye(1)

if len(argv) < 3:
    error("insufficient number of arguments")

fname, field, text = argv[:3]
content_lines = []

def edit_field_line(l, f, s):
    i = l.find(f)
    if i < 0:
        return l, False
    i += len(f)
    while i < len(l) and l[i].isspace():
        i += 1
    return l[:i] + s, True

with open(fname, "r") as fd:
    content_lines = fd.read().split("\n")

for i, l in enumerate(content_lines):
    content_lines[i], changed = edit_field_line(content_lines[i], field, text)
    if changed:
        break

with open(fname, "w") as fd:
    fd.write("\n".join(content_lines))
'

##
# update_header $1 $2 $3
#
#   $1 - file name
#   $2 - field name
#   $3 - field text
#
# Replace $2's text in file $1 by $3 (only the first occurrence of $2 is
# edited).
function update_header() {
  python -c "${header_updater_}" "$@"
}

##
# see_file $1
#
#   $1 - path to file
#
# Emit "See <path to $1 relative to project root>".
function see_file() {
  local E
  local F

  F=$(relpath_of "$1"); E=$?
  [ $E -ne 0 ] && exit $
  echo "See ./$F"
}

##
# see_license $1 $2
#
#   $1 - license type
#   $2 - path to license file
#
# Emit "<license type> (see <path to $2 relative to project root>)".
function see_license() {
  local E
  local F

  F=$(relpath_of "$2"); E=$?
  [ $E -ne 0 ] && exit $E
  echo "$1 (see ./$F)"
}

template MIT_LICENSE_TEMPLATE "\
Copyright (c) @YEAR @AUTHOR.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \"Software\"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"

##
# add_license $1
#
#   $1 - name of license file
#
# Add a $1 to the project directory.
function add_license() {
  local Y
  local E
  local F

  [ -z "$1" ] && error "$FUNCNAME: missing name of license file"
  F=$(dirname "$PKM_MAINTFILE"); F="$F/$1"
  [ -f "$F" ] && { echo "'$F' already exists"; exit 0; }
  [ -d "$F" ] && error "$FUNCNAME: '$F' is a directory"
  [ -z "${ProjectVars[LICENSE]}" ] && error "$FUNCNAME: LICENSE variable has no value"

  case "${ProjectVars[LICENSE]}" in
    MIT)
      Y=$(sh $PKM_PROG stamp "--format=%(tm_year)d"); E=$?
      [ $E -ne 0 ] && exit $E
      expr "$Y" : '^[1-9][0-9]*$' >/dev/null 2>&1 || error "$FUNCNAME: invalid year format '$Y'"
      [ -z "${ProjectVars[AUTHOR_NAME]}" ] && error "$FUNCNAME: author's name's not set"
      eval_template MIT_LICENSE_TEMPLATE YEAR="$Y" AUTHOR="${ProjectVars[AUTHOR_NAME]}" > "$F"
      ;;
    *)
      error "$FUNCNAME: unknown license '${ProjectVars[LICENSE]}'"
  esac
}

template README_MD_TEMPLATE "\
# @PROJECT

WIP
"

##
# add_readme $1
#
#   $1 - name of README file
#
# Add a $1 to the project directory.
function add_readme() {
  local F

  [ -z "$1" ] && error "$FUNCNAME: missing name of README file"
  F=$(dirname "$PKM_MAINTFILE"); F="$F/$1"
  [ -f "$F" ] && { echo "'$F' already exists"; exit 0; }
  [ -d "$F" ] && error "$FUNCNAME: '$F' is a directory"
  [ -z "${ProjectVars[PROJECT]}" ] && error "$FUNCNAME: PROJECT variable has no value"

  case "$F" in
    *.md)
      eval_template README_MD_TEMPLATE PROJECT="${ProjectVars[PROJECT]}" > "$F"
      ;;
    *)
      (
        N=$(expr length "${ProjectVars[PROJECT]}")
        echo "${ProjectVars[PROJECT]}"
        for ((i = 0; i < $N; i++)); do
          echo -n "="
        done
        echo ""
        echo ""
        echo "WIP"
      ) > "$F"
  esac
}

##
# add_version $1
#
#   $1 - name of VERSION file
#
# Add a $1 to the project directory.
function add_version() {
  local F

  [ -z "$1" ] && error "$FUNCNAME: missing name of version file"
  F=$(dirname "$PKM_MAINTFILE"); F="$F/$1"
  [ -f "$F" ] && { echo "'$F' already exists"; exit 0; }
  [ -d "$F" ] && error "$FUNCNAME: '$F' is a directory"
  [ -z "${ProjectVars[VERSION]}" ] && error "$FUNCNAME: VERSION variable has no value"

  echo "${ProjectVars[VERSION]}" > "$F"
}

##
# ensure_specfiles
#
# Ensure there exists ./specfiles/${PKG_NAME}/ directory. This involves also
# cloning ${PKG_NAME} package.
function ensure_specfiles() {
  ensure_dir "${PKM_PRJROOT}/specfiles" && \
  [ "${ProjectVars[PKG_NAME]}" ] && \
  if [ ! -d "${PKM_PRJROOT}/specfiles/${ProjectVars[PKG_NAME]}" ]; then
    (
      cd "${PKM_PRJROOT}/specfiles" && \
      fedpkg clone "${ProjectVars[PKG_NAME]}"
    )
  fi
}

##
# enumerate_sources
#
# Get the list of source archives and print them to the standard output
# (one per line).
function enumerate_sources() {
  local L

  L=$(ls -a1)
  for f in $L; do
    case "$f" in
      *.bz2  | *.gz  | *.xz  | \
      *.tbz2 | *.tgz | *.txz )
        echo "$f"
    esac
  done
}

##
# ensure_sources
#
# Try to get source archives if there are none (use fedpkg prep). Return true
# if operation has succeed.
function ensure_sources() {
  [ -z "$(enumerate_sources)" ] && fedpkg prep
  [ "$(enumerate_sources)" ]
}

##
# cache_sources
#
# Copy source archives to the internal project cache.
function cache_sources() {
  local D

  D="${PKM_PRJROOT}/.${PKM_NAME}/sourcecache"
  ensure_dir "$D" && \
  for a in $(enumerate_sources); do
    cp "$a" "$D/$a"
  done
}

##
# get_sources
#
# Get the source archives and cache them.
function get_sources() {
  [ $PKM_DEBUG -ne 0 ] && set -x
  ensure_specfiles && (
    cd "${PKM_PRJROOT}/specfiles/${ProjectVars[PKG_NAME]}" && \
    ensure_sources && \
    cache_sources
  )
}

##
# unpack_source $1
#
#   $1 - source tarball
#
# Unpack selected tarball from source cache to upstream directory. Do not
# overwrite the existing one.
function unpack_source() {
  local A
  local D
  local T
  declare -A S

  [ $PKM_DEBUG -ne 0 ] && set -x
  D="${PKM_PRJROOT}/.${PKM_NAME}/sourcecache"
  rm -rfd "/var/tmp/${PKM_NAME}"
  [ "$1" ] && \
  ensure_dir "${PKM_PRJROOT}/upstream" && \
  mkdir -p "/var/tmp/${PKM_NAME}" && \
  cp "$D/$1" "/var/tmp/${PKM_NAME}/$1" && \
  dir_read S "/var/tmp/${PKM_NAME}" && \
  (cd "/var/tmp/${PKM_NAME}" && unpack "$1") && \
  T="" && \
  dir_diff S "/var/tmp/${PKM_NAME}" T && \
  [ $(nlines "$T") -eq 1 ] && \
  if [ ! -d "${PKM_PRJROOT}/upstream/$(arcrmext $1)" ]; then
    mv "/var/tmp/${PKM_NAME}/$T" "${PKM_PRJROOT}/upstream/$(arcrmext $1)"
  fi
  rm -rfd "/var/tmp/${PKM_NAME}"
}
