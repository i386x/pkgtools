#
#! \file    ./src/pk-maintrc
#! \author  Jiří Kučera, <jkucera AT redhat.com>
#! \stamp   2018-01-01 02:20:19 (UTC+01:00, DST+00:00)
#! \project pkgtools: Tools for Maintaining Fedora Packages
#! \license MIT (see ./LICENSE)
#! \version See ./VERSION
#! \fdesc   pk-maint configuration.
#

require_command wc
require_command ls
require_command find
require_command mkdir
require_command cp
require_command mv
require_command rm
require_command sleep
require_command tar
require_command gzip
require_command bzip2
require_command git
require_command spectool
require_command fedpkg
require_command rpmlint

###############################################################################
# User configuration
###############################################################################

##
# User settings.
setvar USER_NAME ''
setvar USER_LOGIN ''
setvar USER_EMAIL1 ''
setvar USER_EMAIL2 ''
setvar USER_EMAIL3 ''
setvar USER_EMAIL4 ''
setvar USER_EMAIL5 ''

###############################################################################
# `new-file' command configuration
###############################################################################

##
# newfile_at_guess_template_begin $1 $2
#
#   $1 - variable to store guessed template
#   $2 - file name
#
# Guess a template for $2. Can be overriden by the user.
function newfile_at_guess_template_begin() {
  eval "$1=\"\""
}

##
# newfile_on_guess_template_fail $1 $2
#
#   $1 - variable to store guessed template
#   $2 - file name
#
# Guess a template for $2 if the previous methods have failed or issue an error.
# Can be overriden by the user.
function newfile_on_guess_template_fail() {
  eval "$1=\"\""
}

##
# newfile_at_guess_interpreter_begin $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Determine interpreter at early phase of newfile_guess_interpreter. Can be
# overriden by the user.
function newfile_at_guess_interpreter_begin() {
  echo ""
}

##
# newfile_on_guess_interpreter_fail $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Determine interpreter or raise an error if other attempts fails. Can be
# overriden by the user.
function newfile_on_guess_interpreter_fail() {
  echo "/usr/bin/false"
}

##
# newfile_guess_interpreter $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Determine interpreter for $3.
function newfile_guess_interpreter() {
  local T

  T=$(newfile_at_guess_interpreter_begin "$@")
  if [ "$T" ]; then
    echo "$T"
  else
    case "$1" in
      sh | SH) echo "/bin/sh" ;;
      bash | BASH) echo "/bin/bash" ;;
      py | PY | python | PYTHON) echo "/usr/bin/python" ;;
      *) newfile_on_guess_interpreter_fail "$@"
    esac
  fi
}

##
# newfile_guess_file_path $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Determine path to $3 relative to the project root file or directory location.
# Can be overriden by the user.
function newfile_guess_file_path() {
  local D
  local R

  D=$(pwd)
  R=$(search_upwards "$3" "$2")
  if [ -z "$R" ]; then
    echo "./$3"
  else
    R=$(dirname "$R")
    R=$(compute_relpath "$D/$3" "$R")
    echo "./$R"
  fi
}

##
# newfile_guess_author_name $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Determine the author's name. Can be overriden by the user.
function newfile_guess_author_name() {
  if [ "${ProjectVars[AUTHOR_NAME]}" ]; then
    echo "${ProjectVars[AUTHOR_NAME]}"
  elif [ "${ProjectVars[USER_NAME]}" ]; then
    echo "${ProjectVars[USER_NAME]}"
  else
    echo "Name Surname"
  fi
}

##
# newfile_guess_author_name1 $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Determine the name of the 1st author. Can be overriden by the user.
function newfile_guess_author_name1() {
  if [ "${ProjectVars[AUTHOR1_NAME]}" ]; then
    echo "${ProjectVars[AUTHOR1_NAME]}"
  elif [ "${ProjectVars[USER_NAME]}" ]; then
    echo "${ProjectVars[USER_NAME]}"
  else
    echo "Name Surname"
  fi
}

##
# newfile_guess_author_name2 $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Determine the name of the 2nd author. Can be overriden by the user.
function newfile_guess_author_name2() {
  if [ "${ProjectVars[AUTHOR2_NAME]}" ]; then
    echo "${ProjectVars[AUTHOR2_NAME]}"
  else
    echo "Name Surname"
  fi
}

##
# newfile_guess_author_name3 $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Determine the name of the 3rd author. Can be overriden by the user.
function newfile_guess_author_name3() {
  if [ "${ProjectVars[AUTHOR3_NAME]}" ]; then
    echo "${ProjectVars[AUTHOR3_NAME]}"
  else
    echo "Name Surname"
  fi
}

##
# newfile_guess_author_name4 $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Determine the name of the 4th author. Can be overriden by the user.
function newfile_guess_author_name4() {
  if [ "${ProjectVars[AUTHOR4_NAME]}" ]; then
    echo "${ProjectVars[AUTHOR4_NAME]}"
  else
    echo "Name Surname"
  fi
}

##
# newfile_guess_author_name5 $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Determine the name of the 5th author. Can be overriden by the user.
function newfile_guess_author_name5() {
  if [ "${ProjectVars[AUTHOR5_NAME]}" ]; then
    echo "${ProjectVars[AUTHOR5_NAME]}"
  else
    echo "Name Surname"
  fi
}

##
# newfile_guess_author_email $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Determine author's email address. Can be overriden by the user.
function newfile_guess_author_email() {
  if [ "${ProjectVars[AUTHOR_EMAIL]}" ]; then
    echo "${ProjectVars[AUTHOR_EMAIL]}"
  elif [ "${ProjectVars[USER_EMAIL1]}" ]; then
    echo "${ProjectVars[USER_EMAIL1]}"
  else
    echo "login AT domain.com"
  fi
}

##
# newfile_guess_author_email1 $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Determine an email address of the 1st author. Can be overriden by the user.
function newfile_guess_author_email1() {
  if [ "${ProjectVars[AUTHOR1_EMAIL]}" ]; then
    echo "${ProjectVars[AUTHOR1_EMAIL]}"
  elif [ "${ProjectVars[USER_EMAIL1]}" ]; then
    echo "${ProjectVars[USER_EMAIL1]}"
  else
    echo "login AT domain.com"
  fi
}

##
# newfile_guess_author_email2 $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Determine an email address of the 2nd author. Can be overriden by the user.
function newfile_guess_author_email2() {
  if [ "${ProjectVars[AUTHOR2_EMAIL]}" ]; then
    echo "${ProjectVars[AUTHOR2_EMAIL]}"
  else
    echo "login AT domain.com"
  fi
}

##
# newfile_guess_author_email3 $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Determine an email address of the 3rd author. Can be overriden by the user.
function newfile_guess_author_email3() {
  if [ "${ProjectVars[AUTHOR3_EMAIL]}" ]; then
    echo "${ProjectVars[AUTHOR3_EMAIL]}"
  else
    echo "login AT domain.com"
  fi
}

##
# newfile_guess_author_email4 $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Determine an email address of the 4th author. Can be overriden by the user.
function newfile_guess_author_email4() {
  if [ "${ProjectVars[AUTHOR4_EMAIL]}" ]; then
    echo "${ProjectVars[AUTHOR4_EMAIL]}"
  else
    echo "login AT domain.com"
  fi
}

##
# newfile_guess_author_email5 $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Determine an email address of the 5th author. Can be overriden by the user.
function newfile_guess_author_email5() {
  if [ "${ProjectVars[AUTHOR5_EMAIL]}" ]; then
    echo "${ProjectVars[AUTHOR5_EMAIL]}"
  else
    echo "login AT domain.com"
  fi
}

##
# newfile_guess_stamp $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Get the time date stamp string of $3. Can be overriden by the user.
function newfile_guess_stamp() {
  local F

  F=$(eval_template NEWFILE_STAMP_FORMAT)
  sh $PKM_PROG $PKM_INIT stamp "--file=$3" "--format=$F"
}

##
# newfile_guess_project_desc $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Get the project description. Can be overriden by the user.
function newfile_guess_project_desc() {
  if [ "${ProjectVars[PROJECT]}" ]; then
    echo "${ProjectVars[PROJECT]}"
  else
    echo "???"
  fi
}

##
# newfile_guess_license $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Get the project license. Can be overriden by the user.
function newfile_guess_license() {
  if [ "${ProjectVars[LICENSE]}" ]; then
    echo "${ProjectVars[LICENSE]}"
  else
    echo "???"
  fi
}

##
# newfile_guess_version $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Get the project version. Can be overriden by the user.
function newfile_guess_version() {
  if [ "${ProjectVars[VERSION]}" ]; then
    echo "${ProjectVars[VERSION]}"
  else
    echo "???"
  fi
}

##
# newfile_guess_file_desc $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Get the file description. Can be overriden by the user.
function newfile_guess_file_desc() {
  if [ "$NEWFILEOPT_FDESC" ]; then
    echo "$NEWFILEOPT_FDESC"
  else
    echo "???"
  fi
}

##
# newfile_guess_guard $1 $2 $3
#
#   $1 - template type
#   $2 - name of the unique file or directory in project root
#   $3 - file name
#
# Derive the name of include guards used inside C header files.
function newfile_guess_guard() {
  local P
  local T

  P=$(newfile_guess_file_path "$@")
  P="${P#./}"
  [ "${ProjectVars[SOURCE_DIR]}" ] && {
    P="${P#${ProjectVars[SOURCE_DIR]}}"
    P="${P#/}"
  }
  if [ "${ProjectVars[PROJECT_SHORT]}" ]; then
    P="${ProjectVars[PROJECT_SHORT]}_${P}"
  else
    T=$(search_upwards "$3" "$2")
    [ "$T" ] && { T="${T%/$2}"; T="${T##*/}"; }
    [ "$T" ] && { P="${T}_${P}"; }
  fi
  echo "$P" | tr 'a-z/.-' 'A-Z___'
}

##
# newfile_gen_header_template $1 $2 ... $n
#
#   $1, $2, ..., $n - commands with their arguments
#
# Assemble file header template and send it to stdout. The meaning of commands
# together with their arguments is following:
#
#   -b        emit shebang line
#   -u X      emit a line of the length 79 characters starting with X and ending
#             with -*- coding: utf-8 -*-
#   -c X      emit X
#   -l X Y    emit field line beginning with X and ending with Y
#   -F X      emit path to file line beginning with X
#   -A X      emit author line beginning with X
#   -T X      emit time date stamp line beginning with X
#   -P X      emit project description line beginning with X
#   -L X      emit project license line beginning with X
#   -V X      emit project version line beginning with X
#   -B X      emit file description (brief) line beginning with X
#   -H X      emit all field lines, each line is starting with X
#
function newfile_gen_header_template() {
  while [ $# -gt 0 ]; do
    case "$1" in
      -b)
        echo "#!@INTERPRETER"
        shift
        ;;
      -u)
        text_to_right "$2" "-*- coding: utf-8 -*-" 79
        shift 2
        ;;
      -c)
        echo "$2"
        shift 2
        ;;
      -l)
        echo "$2!          $3"
        shift 3
        ;;
      -F)
        echo "$2! \\\\file    @FILE"
        shift 2
        ;;
      -A)
        echo "$2! \\\\author  @AUTHOR"
        shift 2
        ;;
      -T)
        echo "$2! \\\\stamp   @STAMP"
        shift 2
        ;;
      -P)
        echo "$2! \\\\project @PROJECT_DESC"
        shift 2
        ;;
      -L)
        echo "$2! \\\\license @LICENSE"
        shift 2
        ;;
      -V)
        echo "$2! \\\\version @VERSION"
        shift 2
        ;;
      -B)
        echo "$2! \\\\fdesc   @FILE_DESC"
        shift 2
        ;;
      -H)
        echo "$2! \\\\file    @FILE_PATH"
        echo "$2! \\\\author  @AUTHOR"
        echo "$2! \\\\stamp   @STAMP"
        echo "$2! \\\\project @PROJECT_DESC"
        echo "$2! \\\\license @LICENSE"
        echo "$2! \\\\version @VERSION"
        echo "$2! \\\\fdesc   @FILE_DESC"
        shift 2
        ;;
    esac
  done
}

##
# newfile_template_args
#
# Return additional template arguments. Can be overriden by the user.
function newfile_template_args() {
  echo -n "AUTHOR=NEWFILE_AUTHOR_TEMPLATE"
  echo -n " AUTHOR1=NEWFILE_AUTHOR1_TEMPLATE"
  echo -n " AUTHOR2=NEWFILE_AUTHOR2_TEMPLATE"
  echo -n " AUTHOR3=NEWFILE_AUTHOR3_TEMPLATE"
  echo -n " AUTHOR4=NEWFILE_AUTHOR4_TEMPLATE"
  echo    " AUTHOR5=NEWFILE_AUTHOR5_TEMPLATE"
}

config new-file INTERPRETER "\$(newfile_guess_interpreter \"\$T\" \"\$R\" \"\$F\")"
config new-file FILE_PATH "\$(newfile_guess_file_path \"\$T\" \"\$R\" \"\$F\")"

template NEWFILE_AUTHOR_TEMPLATE "@AUTHOR_NAME, <@AUTHOR_EMAIL>"
template NEWFILE_AUTHOR1_TEMPLATE "@AUTHOR1_NAME, <@AUTHOR1_EMAIL>"
template NEWFILE_AUTHOR2_TEMPLATE "@AUTHOR2_NAME, <@AUTHOR2_EMAIL>"
template NEWFILE_AUTHOR3_TEMPLATE "@AUTHOR3_NAME, <@AUTHOR3_EMAIL>"
template NEWFILE_AUTHOR4_TEMPLATE "@AUTHOR4_NAME, <@AUTHOR4_EMAIL>"
template NEWFILE_AUTHOR5_TEMPLATE "@AUTHOR5_NAME, <@AUTHOR5_EMAIL>"
template NEWFILE_AUTHORS_TEMPLATE "See ./AUTHORS"

config new-file AUTHOR_NAME "\$(newfile_guess_author_name \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR_EMAIL "\$(newfile_guess_author_email \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR1_NAME "\$(newfile_guess_author_name1 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR1_EMAIL "\$(newfile_guess_author_email1 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR2_NAME "\$(newfile_guess_author_name2 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR2_EMAIL "\$(newfile_guess_author_email2 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR3_NAME "\$(newfile_guess_author_name3 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR3_EMAIL "\$(newfile_guess_author_email3 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR4_NAME "\$(newfile_guess_author_name4 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR4_EMAIL "\$(newfile_guess_author_email4 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR5_NAME "\$(newfile_guess_author_name5 \"\$T\" \"\$R\" \"\$F\")"
config new-file AUTHOR5_EMAIL "\$(newfile_guess_author_email5 \"\$T\" \"\$R\" \"\$F\")"

config new-file DATE_FMT "%Y-%m-%d"
config new-file TIME_FMT "%H:%M:%S"
config new-file UTC_FMT "%!0z%!1z:%!2z"
config new-file DST_FMT "%*0z%*1z:%*2z"

template NEWFILE_STAMP_FORMAT "@DATE_FMT @TIME_FMT (UTC@UTC_FMT, DST@DST_FMT)"

config new-file STAMP "\$(newfile_guess_stamp \"\$T\" \"\$R\" \"\$F\")"
config new-file PROJECT_DESC "\$(newfile_guess_project_desc \"\$T\" \"\$R\" \"\$F\")"
config new-file LICENSE "\$(newfile_guess_license \"\$T\" \"\$R\" \"\$F\")"
config new-file VERSION "\$(newfile_guess_version \"\$T\" \"\$R\" \"\$F\")"
config new-file FILE_DESC "\$(newfile_guess_file_desc \"\$T\" \"\$R\" \"\$F\")"
config new-file GUARD "\$(newfile_guess_guard \"\$T\" \"\$R\" \"\$F\")"

template NEWFILE_NASM_HEADER_TEMPLATE \
  "$(newfile_gen_header_template -c ';' -H ';' -c ';')" \
  $(newfile_template_args)
template NEWFILE_C_HEADER_TEMPLATE \
  "$(newfile_gen_header_template -c '/*' -H ' *' -c ' *' -c ' */')" \
  $(newfile_template_args)
template NEWFILE_PY_HEADER_TEMPLATE \
  "$(newfile_gen_header_template -u '#' -H '#' -c '#')" \
  $(newfile_template_args)
template NEWFILE_MAKEFILE_HEADER_TEMPLATE \
  "$(newfile_gen_header_template -c '#' -H '#' -c '#')" \
  $(newfile_template_args)

template NEWFILE_PLAIN_TEMPLATE ""

template NEWFILE_PKM_GITIGNORE_TEMPLATE "\
.pk-maint/log
/upstream
/downstream
/specfiles/*
!/specfiles/*-init/
"

template NEWFILE_ASM_TEMPLATE "\
@HEADER
" HEADER=NEWFILE_NASM_HEADER_TEMPLATE

template NEWFILE_C_TEMPLATE "\
@HEADER
" HEADER=NEWFILE_C_HEADER_TEMPLATE

template NEWFILE_H_TEMPLATE "\
@HEADER

#ifndef @GUARD
#define @GUARD

#endif
" HEADER=NEWFILE_C_HEADER_TEMPLATE

template NEWFILE_PY_TEMPLATE "\
@HEADER
" HEADER=NEWFILE_PY_HEADER_TEMPLATE

template NEWFILE_MAKEFILE_TEMPLATE "\
@HEADER
" HEADER=NEWFILE_MAKEFILE_HEADER_TEMPLATE

template NEWFILE_MAINTFILE_TEMPLATE "\
@HEADER

# Project variables:
setvar PROJECT '\"'@XPROJECT maintenance tools'\"'
setvar AUTHOR_NAME '\"'@XAUTHOR_NAME'\"'
setvar AUTHOR_EMAIL '\"'@XAUTHOR_EMAIL'\"'
setvar LICENSE '\"'MIT'\"'
setvar VERSION '\"'0.0.0'\"'

setvar PKG_NAME '\"'@XPKG_NAME'\"'
setvar PKG_VERSION '\"''\"'
setvar UPSTREAM_REPO \"\"
setvar DOWNSTREAM_REPO \"\"

# Project files:
addfile license : LICENSE
addfile version : VERSION
addfile : .gitignore README.md
addfile sources : Maintfile

###############################################################################
# Project maintaining tasks (targets)
###############################################################################

##
# Print usage as default.
tg_default() {
  echo '\"'Maintfile targets:'\"'
  echo '\"''\"'
  echo '\"'  get_repos'\"'
  echo '\"'    get upstream, downstream and package repos'\"'
  echo '\"'  missing'\"'
  echo '\"'    add missing files to the project root (LICENSE, README.md, and'\"'
  echo '\"'    VERSION) and update headers of source files (\\\\\\\\project, \\\\\\\\license,'\"'
  echo '\"'    and \\\\\\\\version)'\"'
  echo '\"''\"'
}

##
# missing
#
# Add missing files to the project root (LICENSE, README.md, and VERSION) and
# update headers of source files (\\\\project, \\\\license, and \\\\version).
target missing

##
# get_repos
#
# Get upstream, downstream and package repos.
target get_repos
" HEADER=NEWFILE_MAKEFILE_HEADER_TEMPLATE

template NEWFILE_GOPKG_MAINTFILE_TEMPLATE "\
@HEADER

# Project variables:
setvar PROJECT '\"'@XPROJECT maintenance tools'\"'
setvar AUTHOR_NAME '\"'@XAUTHOR_NAME'\"'
setvar AUTHOR_EMAIL '\"'@XAUTHOR_EMAIL'\"'
setvar LICENSE '\"'MIT'\"'
setvar VERSION '\"'0.0.0'\"'

setvar PKG_NAME '\"'@XPKG_NAME'\"'
setvar PKG_VERSION '\"'0'\"'
setvar PKG_COMMIT '\"''\"'
setvar PKG_COMMITDATE '\"''\"'

# Sets:
# - PKG_SHORTCOMMIT
# - GOPKG_PROVIDER
# - GOPKG_PROVIDER_TLD
# - GOPKG_PROJECT
# - GOPKG_REPO
# - GOPKG_SRCDIR
# - UPSTREAM_REPO
gopkg_meta

# Project files:
addfile license : LICENSE
addfile version : VERSION
addfile : .gitignore README.md
addfile sources : Maintfile

###############################################################################
# Project maintaining tasks (targets)
###############################################################################

##
# Print usage as default.
tg_default() {
  echo '\"'Maintfile targets:'\"'
  echo '\"''\"'
  echo '\"'  get_repos'\"'
  echo '\"'    get upstream, downstream and package repos'\"'
  echo '\"'  missing'\"'
  echo '\"'    add missing files to the project root (LICENSE, README.md, and'\"'
  echo '\"'    VERSION) and update headers of source files (\\\\\\\\project, \\\\\\\\license,'\"'
  echo '\"'    and \\\\\\\\version)'\"'
  echo '\"''\"'
}

##
# missing
#
# Add missing files to the project root (LICENSE, README.md, and VERSION) and
# update headers of source files (\\\\project, \\\\license, and \\\\version).
target missing

##
# get_repos
#
# Get upstream, downstream and package repos.
target get_repos
" HEADER=NEWFILE_MAKEFILE_HEADER_TEMPLATE

###############################################################################
# `Maintfile' library
###############################################################################

##
# arcrmext $1
#
#   $1 - tarball name
#
# Remove $1's extension.
function arcrmext() {
  local T

  T="$1"
  case "$T" in
    *.tar.*)
      echo "${T%.tar.*}"
      ;;
    *)
      echo "${T%.*}"
  esac
}

##
# nlines $1
#
#   $1 - text
#
# Count lines in $1.
function nlines() {
  echo "$1" | wc -l
}

##
# dir_read $1 $2
#
#   $1 - container (associative array)
#   $2 - directory
#
# Save all item names in $2 to $1.
function dir_read() {
  for f in $(ls -a1 "$2"); do
    eval "$1[$f]=1"
  done
}

##
# dir_diff $1 $2 $3
#
#   $1 - container (associative array)
#   $2 - directory
#   $3 - result
#
# Record all item names (one per line) from $2 that are not recorded in $1 to
# $3.
function dir_diff() {
  for f in $(ls -a1 "$2"); do
    eval "\
      if [ -z \"\${$1[$f]}\" ]; then
        if [ -z \"\${$3}\" ]; then
          $3=\"$f\"
        else
          $3=\"\${$3}\${nl_sep}$f\"
        fi
      fi
    "
  done
}

##
# assert_dir $1
#
#   $1 - path to directory
#
# Fail if $1 is not a directory.
function assert_dir() {
  [ -d "$1" ] || error "$FUNCNAME: $1 is not a directory"
}

##
# ensure_dir $1
#
#   $1 - directory name
#
# Test if $1 exists. If not, create it. If $1 is a file, fail.
function ensure_dir() {
  [ -f "$1" ] && error "$FUNCNAME: $1 is a file"
  [ -d "$1" ] || mkdir -p "$1"
  [ -d "$1" ] || error "$FUNCNAME: can't create $1"
}

##
# unpack $1
#
#   $1 - archive
#
# Unpack $1 to the current working directory.
function unpack() {
  case "$1" in
    *.tar.gz | *.tgz)
      gzip -dc "$1" | tar -xvvof -
      ;;
    *.tar.bz2)
      bzip2 -dc "$1" | tar -xvvof -
      ;;
    *)
      error "$FUNCNAME: I don't know how to unpack '$1'"
  esac
}

##
# relpath_of $1
#
#   $1 - file name
#
# Return a path to $1 relative to the project root directory. If $1 contain
# LFs, first line is taken as an argument.
function relpath_of() {
  local R
  local F

  [ -z "$1" ] && error "$FUNCNAME: no file given"
  F=$(echo "$1" | head -n 1)
  [ -z "$F" ] && error "$FUNCNAME: empty file name"
  case "$F" in
    /*) : ;;
    *) F="$(pwd)/$F" ;;
  esac
  R=$(dirname "$PKM_MAINTFILE")
  compute_relpath "$F" "$R"
}

# Python is more safe then sed in some circumstances:
header_updater_='
import sys

bye = sys.exit
argv = sys.argv[1:]

def error(msg, *args):
    sys.stderr.write("header_updater: %s\n" % (msg % args))
    bye(1)

if len(argv) < 3:
    error("insufficient number of arguments")

fname, field, text = argv[:3]
content_lines = []

def edit_field_line(l, f, s):
    i = l.find(f)
    if i < 0:
        return l, False
    i += len(f)
    while i < len(l) and l[i].isspace():
        i += 1
    return l[:i] + s, True

with open(fname, "r") as fd:
    content_lines = fd.read().split("\n")

for i, l in enumerate(content_lines):
    content_lines[i], changed = edit_field_line(content_lines[i], field, text)
    if changed:
        break

with open(fname, "w") as fd:
    fd.write("\n".join(content_lines))
'

##
# update_header $1 $2 $3
#
#   $1 - file name
#   $2 - field name
#   $3 - field text
#
# Replace $2's text in file $1 by $3 (only the first occurrence of $2 is
# edited).
function update_header() {
  python -c "${header_updater_}" "$@"
}

##
# see_file $1
#
#   $1 - path to file
#
# Emit "See <path to $1 relative to project root>".
function see_file() {
  local E
  local F

  F=$(relpath_of "$1"); E=$?
  [ $E -ne 0 ] && exit $
  echo "See ./$F"
}

##
# see_license $1 $2
#
#   $1 - license type
#   $2 - path to license file
#
# Emit "<license type> (see <path to $2 relative to project root>)".
function see_license() {
  local E
  local F

  F=$(relpath_of "$2"); E=$?
  [ $E -ne 0 ] && exit $E
  echo "$1 (see ./$F)"
}

template MIT_LICENSE_TEMPLATE "\
Copyright (c) @YEAR @AUTHOR.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \"Software\"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"

##
# add_license $1
#
#   $1 - name of license file
#
# Add a $1 to the project directory.
function add_license() {
  local Y
  local E
  local F

  [ -z "$1" ] && error "$FUNCNAME: missing name of license file"
  F=$(dirname "$PKM_MAINTFILE"); F="$F/$1"
  [ -f "$F" ] && { echo "'$F' already exists"; exit 0; }
  [ -d "$F" ] && error "$FUNCNAME: '$F' is a directory"
  [ -z "${ProjectVars[LICENSE]}" ] && error "$FUNCNAME: LICENSE variable has no value"

  case "${ProjectVars[LICENSE]}" in
    MIT)
      Y=$(sh $PKM_PROG $PKM_INIT stamp "--format=%Y"); E=$?
      [ $E -ne 0 ] && exit $E
      expr "$Y" : '^[1-9][0-9]*$' >/dev/null 2>&1 || error "$FUNCNAME: invalid year format '$Y'"
      [ -z "${ProjectVars[AUTHOR_NAME]}" ] && error "$FUNCNAME: author's name's not set"
      eval_template MIT_LICENSE_TEMPLATE YEAR="$Y" AUTHOR="${ProjectVars[AUTHOR_NAME]}" > "$F"
      ;;
    *)
      error "$FUNCNAME: unknown license '${ProjectVars[LICENSE]}'"
  esac
}

template README_MD_TEMPLATE "\
# @PROJECT

WIP
"

##
# add_readme $1
#
#   $1 - name of README file
#
# Add a $1 to the project directory.
function add_readme() {
  local F

  [ -z "$1" ] && error "$FUNCNAME: missing name of README file"
  F=$(dirname "$PKM_MAINTFILE"); F="$F/$1"
  [ -f "$F" ] && { echo "'$F' already exists"; exit 0; }
  [ -d "$F" ] && error "$FUNCNAME: '$F' is a directory"
  [ -z "${ProjectVars[PROJECT]}" ] && error "$FUNCNAME: PROJECT variable has no value"

  case "$F" in
    *.md)
      eval_template README_MD_TEMPLATE PROJECT="${ProjectVars[PROJECT]}" > "$F"
      ;;
    *)
      (
        N=$(expr length "${ProjectVars[PROJECT]}")
        echo "${ProjectVars[PROJECT]}"
        for ((i = 0; i < $N; i++)); do
          echo -n "="
        done
        echo ""
        echo ""
        echo "WIP"
      ) > "$F"
  esac
}

##
# add_version $1
#
#   $1 - name of VERSION file
#
# Add a $1 to the project directory.
function add_version() {
  local F

  [ -z "$1" ] && error "$FUNCNAME: missing name of version file"
  F=$(dirname "$PKM_MAINTFILE"); F="$F/$1"
  [ -f "$F" ] && { echo "'$F' already exists"; exit 0; }
  [ -d "$F" ] && error "$FUNCNAME: '$F' is a directory"
  [ -z "${ProjectVars[VERSION]}" ] && error "$FUNCNAME: VERSION variable has no value"

  echo "${ProjectVars[VERSION]}" > "$F"
}

##
# edit_source $1
#
#   $1 - source file
#
# Update \project, \license, and \version fields in $1's header.
function edit_source() {
  local T

  update_header "${PKM_PRJROOT}/$1" project "${ProjectVars[PROJECT]}" && \
  T=$(see_license "${ProjectVars[LICENSE]}" "${ProjectFiles[license]}") && \
  update_header "${PKM_PRJROOT}/$1" license "$T" && \
  T=$(see_file "${ProjectFiles[version]}") && \
  update_header "${PKM_PRJROOT}/$1" version "$T"
}

##
# missing
#
# Add missing files to the project root (LICENSE, README.md, and VERSION) and
# update headers of source files (\project, \license, and \version).
function missing() {
  add_license LICENSE && \
  add_readme  README.md && \
  add_version VERSION && \
  for_files sources edit_source
}

##
# ensure_specfiles
#
# Ensure there exists ./specfiles/${PKG_NAME}/ directory. This involves also
# cloning ${PKG_NAME} package.
function ensure_specfiles() {
  ensure_dir "${PKM_PRJROOT}/specfiles" && \
  [ "${ProjectVars[PKG_NAME]}" ] && \
  if [ ! -d "${PKM_PRJROOT}/specfiles/${ProjectVars[PKG_NAME]}" ]; then
    (
      cd "${PKM_PRJROOT}/specfiles" && \
      fedpkg clone "${ProjectVars[PKG_NAME]}"
    )
  fi
}

##
# enumerate_sources
#
# Get the list of source archives and print them to the standard output
# (one per line).
function enumerate_sources() {
  local L

  L=$(ls -a1)
  for f in $L; do
    case "$f" in
      *.bz2  | *.gz  | *.xz  | \
      *.tbz2 | *.tgz | *.txz )
        echo "$f"
    esac
  done
}

##
# ensure_sources
#
# Try to get source archives if there are none (use fedpkg prep). Return true
# if operation has succeed.
function ensure_sources() {
  [ -z "$(enumerate_sources)" ] && fedpkg prep
  [ "$(enumerate_sources)" ]
}

##
# cache_sources
#
# Copy source archives to the internal project cache.
function cache_sources() {
  local D

  D="${PKM_PRJROOT}/.${PKM_NAME}/sourcecache"
  ensure_dir "$D" && \
  for a in $(enumerate_sources); do
    cp "$a" "$D/$a"
  done
}

##
# get_sources
#
# Get the source archives and cache them.
function get_sources() {
  [ $PKM_DEBUG -ne 0 ] && set -x
  ensure_specfiles && (
    cd "${PKM_PRJROOT}/specfiles/${ProjectVars[PKG_NAME]}" && \
    ensure_sources && \
    cache_sources
  )
}

##
# unpack_source $1
#
#   $1 - source tarball
#
# Unpack selected tarball from source cache to downstream directory. Do not
# overwrite the existing one.
function unpack_source() {
  local D
  local T
  local E
  declare -A S

  [ $PKM_DEBUG -ne 0 ] && set -x
  D="${PKM_PRJROOT}/.${PKM_NAME}/sourcecache"
  rm -rfd "/var/tmp/${PKM_NAME}"
  [ "$1" ] && \
  ensure_dir "${PKM_PRJROOT}/downstream" && \
  mkdir -p "/var/tmp/${PKM_NAME}" && \
  cp "$D/$1" "/var/tmp/${PKM_NAME}/$1" && \
  dir_read S "/var/tmp/${PKM_NAME}" && \
  (cd "/var/tmp/${PKM_NAME}" && unpack "$1") && \
  T="" && \
  dir_diff S "/var/tmp/${PKM_NAME}" T && \
  [ $(nlines "$T") -eq 1 ] && \
  if [ ! -d "${PKM_PRJROOT}/downstream/$(arcrmext $1)" ]; then
    mv "/var/tmp/${PKM_NAME}/$T" "${PKM_PRJROOT}/downstream/$(arcrmext $1)"
  fi
  E=$?
  rm -rfd "/var/tmp/${PKM_NAME}"
  return $E
}

##
# get_repos
#
# Get upstream, downstream and package repos.
function get_repos() {
  local R
  local T

  [ $PKM_DEBUG -ne 0 ] && set -x
  R="${PKM_PRJROOT}"
  # Get upstream repo:
  if [ "${ProjectVars[UPSTREAM_REPO]}" ]; then
    T="${ProjectVars[UPSTREAM_REPO]##*/}"
    T="${T%.git}"
    [ -d "$R/upstream" ] || mkdir "$R/upstream"
    [ -d "$R/upstream" ] && (
      cd "$R/upstream" && \
      if [ ! -d "$T/.git" ]; then
        git clone "${ProjectVars[UPSTREAM_REPO]}"
      fi
    )
  fi
  # Get downstream repo:
  if [ "${ProjectVars[DOWNSTREAM_REPO]}" ]; then
    T="${ProjectVars[DOWNSTREAM_REPO]##*/}"
    T="${T%.git}"
    [ -d "$R/downstream" ] || mkdir "$R/downstream"
    [ -d "$R/downstream" ] && (
      cd "$R/downstream" && \
      if [ ! -d "$T/.git" ]; then
        git clone "${ProjectVars[DOWNSTREAM_REPO]}"
      fi
    )
  fi
  # Get package repo:
  if [ "${ProjectVars[PKG_NAME]}" ]; then
    [ -d "$R/specfiles" ] || mkdir "$R/specfiles"
    [ -d "$R/specfiles" ] && (
      cd "$R/specfiles" && \
      if [ ! -d "${ProjectVars[PKG_NAME]}/.git" ]; then
        fedpkg clone "${ProjectVars[PKG_NAME]}"
      fi
    )
  fi
}

##
# ds_prep $1 $2
#
#   $1 - target with unpacked sources
#   $2 - target's new name
#
# Prepare downstream (rename $1 to $2, cd to $2, and do git init).
function ds_prep() {
  local D

  [ $PKM_DEBUG -ne 0 ] && set -x
  D="${PKM_PRJROOT}/downstream"
  [ "$1" ] && [ "$2" ] && \
  [ -d "$D/$1" ] && \
  [ ! -d "$D/$1/.git" ] && \
  [ ! -d "$D/$2" ] && \
  mv "$D/$1" "$D/$2" && (
    cd "$D/$2" && \
    git init
  )
}

##
# make_patch $1 $2 [$3]
#
#   $1 - git branch/tag name or commit (from)
#   $2 - patch name
#   $3 - git branch/tag name or commit (to)
#
# Make {PKG_NAME}-{PKG_VERSION}-$2.patch from diff between $1 and $3. If $3 is
# omitted, master is used.
function make_patch() {
  local D
  local P
  local T
  local U

  [ $PKM_DEBUG -ne 0 ] && set -x
  [ "$1" ] && [ "$2" ] && U="$3" && \
  { [ -z "$U" ] && U="master" || :; } && \
  D="${PKM_PRJROOT}/downstream/${ProjectVars[PKG_NAME]}-downstream" && \
  P="${ProjectVars[PKG_NAME]}-${ProjectVars[PKG_VERSION]}-$2.patch" && \
  T=$(cd $D && git diff $U $1) && \
  if [ "$T" ]; then
    echo "$T" > "${PKM_PRJROOT}/specfiles/${ProjectVars[PKG_NAME]}/$P"
  fi
}

##
# rpm_lint
#
# Collect spec files and (s)rmp files and run rpmlint on them.
function rpm_lint() {
  [ $PKM_DEBUG -ne 0 ] && set -x
  do_rpmlint --workdir "${PKM_PRJROOT}/specfiles/${ProjectVars[PKG_NAME]}"
}

##
# do_rpmlint $1 $2 ... $n
#
#   $1, $2, ..., $n - options
#
# Run `rpmlint` command. Options are:
#
#   --specname NAME - specify specfile name
#   --workdir PATH  - specify working directory
#   --with-logging  - save the results to the common logfile
#
function do_rpmlint() {
  local C
  local L
  local S
  local W

  L=eval
  while [ $# -gt 0 ]; do
    case "$1" in
      --specname)
        S="$2"
        shift 2
        ;;
      --workdir)
        W="$2"
        shift 2
        ;;
      --with-logging)
        L=log_command
        shift
        ;;
      *) error "$FUNCNAME: invalid option: $1" ;;
    esac
  done
  [ "$S" ] || S="${ProjectVars[PKG_NAME]}"
  [ "$S" ] || error "$FUNCNAME: missing specfile name"
  [ "$W" ] && { [ -d "$W" ] || error "$FUNCNAME: $W is not a directory"; }

  [ "$W" ] && pushd "$W" > /dev/null
  C="rpmlint $S.spec"
  for f in $(find . -iname "*.rpm"); do
    C="$C $f"
  done
  $L "$C"
  popd > /dev/null
}

revert_po_commands_generator_='
import sys
import re

po_re = re.compile(r"^po/[^/]+\.po$")

class CheckError(Exception):
    pass

def check(cond, msg, *args):
    if not cond:
        raise CheckError(msg % args)

class Diff(object):
    __slots__ = [ "name", "commands" ]

    def __init__(self, name):
        self.name = name
        self.commands = []

    def add(self, l):
        self.commands.append((1, l))

    def remove(self, l):
        self.commands.append((-1, l))

class DiffSet(object):
    __slots__ = [ "diffs" ]

    def __init__(self):
        self.diffs = {}

    def getlast(self):
        check(1 in self.diffs, "No diffs")
        return self.diffs[1]

    def add(self, diff):
        if not self.diffs:
            self.diffs[0] = diff
        check(diff.name not in self.diffs, "Duplicit item (%r)", diff.name)
        last = self.diffs.get(1)
        if last:
            self.diffs[last.name] = (last, diff)
        self.diffs[diff.name] = (diff, None)
        self.diffs[1] = diff

    def forall(self, p):
        o = self.diffs.get(0)
        while o:
            if not p(o):
                return False
            o = self.diffs[o.name][1]
        return True

class DiffScanner(object):
    DIFF_GIT = "diff --git "
    __slots__ = [ "lines", "nlines", "pos" ]

    def __init__(self, s):
        self.lines = [ l for l in s.split("\n") if l ]
        self.nlines = len(self.lines)
        self.pos = 0

    def eof(self):
        return self.pos >= self.nlines

    def current_line(self):
        if not self.eof():
            return self.lines[self.pos]
        return None

    def read_diff_git(self, f):
        lines, i, n = self.lines, self.pos, self.nlines
        while i < n and not lines[i].startswith(self.DIFF_GIT):
            i += 1
        check(i < n, "Missing %r", self.DIFF_GIT)
        line = lines[i]
        parts = line[len(self.DIFF_GIT):].strip().split(" ")
        parts = [ p.strip() for p in parts ]
        parts = [ x for x in parts if x ]
        check(
            len(parts) == 2 \
            and parts[0].startswith("a/") \
            and parts[1].startswith("b/") \
            and len(parts[0][2:]) > 0 \
            and parts[0][2:] == parts[1][2:],
            "Invalid %r (%r)", self.DIFF_GIT, line
        )
        f(self, parts[0][2:])
        self.pos = i + 1

    def read_line(self, prefix, f):
        check(self.pos < self.nlines, "End of file reached")
        line = self.lines[self.pos]
        check(line.startswith(prefix), "%r not starts with %r", line, prefix)
        f(self, line)
        self.pos += 1

    def read_lines(self, f):
        lines, i, n = self.lines, self.pos, self.nlines
        while i < n and f(self, lines[i]):
            i += 1
        self.pos = i

def read_diff_from_file(diffset, path):
    with open(path, "r") as f:
        read_diff_from_str(diffset, f.read())

def read_diff_from_str(diffset, s):
    def add_diff(scanner, name):
        diffset.add(Diff(name))
    def skip(scanner, x):
        pass
    def online(scanner, line):
        if line.startswith("@@ "):
            return True
        elif line.startswith(" "):
            return True
        elif line.startswith("+"):
            diffset.getlast().add(line[1:])
            return True
        elif line.startswith("-"):
            diffset.getlast().remove(line[1:])
            return True
        return False
    scanner = DiffScanner(s)
    while not scanner.eof():
        scanner.read_diff_git(add_diff)
        scanner.read_line("index ", skip)
        scanner.read_line("--- ", skip)
        scanner.read_line("+++ ", skip)
        scanner.read_lines(online)
    check(scanner.eof(), "Uprocessed input (%r)", scanner.current_line())

def only_po_files(diff):
    return po_re.match(diff.name) is not None

def only_pot_creation_date_changed(diff):
    return (
        len(diff.commands) == 2 \
        and diff.commands[0][0] == -diff.commands[1][0] \
        and diff.commands[0][1].startswith("\"POT-Creation-Date: ") \
        and diff.commands[1][1].startswith("\"POT-Creation-Date: ")
    )

def generate_revert_command(diff):
    sys.stdout.write("git checkout -- %r\n" % diff.name)
    return True

def main(argv):
    try:
        check(len(argv) > 0, "Expected file name")
        diffset = DiffSet()
        read_diff_from_file(diffset, argv[0])
        check(diffset.forall(only_po_files), "Not only .po files has changed")
        check(diffset.forall(only_pot_creation_date_changed),
            "Not only POT-Creation-Date has changed"
        )
        diffset.forall(generate_revert_command)
    except IOError:
        sys.stderr.write("File %r cannot be read.\n" % argv[0])
        return 1
    except CheckError as e:
        sys.stderr.write("%s.\n" % e.args[0])
        return 1
    return 0

sys.exit(main(sys.argv[1:]))
'

##
# revert_po
#
# Discard changes in *.po files if the change is only POT-Creation-Date.
function revert_po() {(
  local T
  local U

  T="/var/tmp/git-diff.$$"
  U="/var/tmp/revert-po-$$.sh"
  [ $PKM_DEBUG -ne 0 ] && set -x
  cd "${PKM_PRJROOT}/upstream/${ProjectVars[PKG_NAME]}" && \
  git diff > $T && \
  python -c "${revert_po_commands_generator_}" $T > $U && \
  if [ $PKM_DEBUG -ne 0 ]; then
    cat $U
  else
    sh $U
  fi
  rm -f $T $U
)}

##
# srpm $1 $2 ... $n
#
#   $1              - command
#   $2, $3, ..., $n - command options
#
# Make source rpm from specfile. Usage:
#
#   srpm --init
#     Initialize temporary workplace. A path to temporary workplace is
#     "${TMP_WORKPLACE}/srpm/$PKG_NAME". If TMP_WORKPLACE is not set, its
#     default value is '.pk-maint/tmp'.
#   srpm --show WHAT
#     Show the value of WHAT, where WHAT can be:
#     - srcdir - show the path to the directory with specfile;
#     - destdir - show the path to the directory with the made srpms;
#     - workdir - show the path to the workplace.
#   srpm --copyin PATH
#     Copy PATH into the workplace and start track it.
#   srpm --copyout PATH
#     Copy file to PATH. The name of the file is the last element of PATH.
#   srpm --commit
#     Commit the tracked files to the internal git repo.
#   srpm --get-sources
#     Download sources listed in specfile.
#   srpm --srpm [RELEASE]
#     Make source RPM for RELEASE. If RELEASE is omitted, `master' is used.
#   srpm --lint
#     Run rpmlint, save results to common the logfile.
#   srpm --clean
#     Remove untracked files from the workplace.
#   srpm --done
#     Finish work, cleanup the workplace.
#
function srpm() {
  case $1 in
    --init)
      shift
      srpm_init "$@"
      ;;
    --show)
      shift
      srpm_show "$@"
      ;;
    --copyin)
      shift
      srpm_copyin "$@"
      ;;
    --copyout)
      shift
      srpm_copyout "$@"
      ;;
    --commit)
      shift
      srpm_commit "$@"
      ;;
    --get-sources)
      shift
      srpm_get_sources "$@"
      ;;
    --srpm)
      shift
      srpm_srpm "$@"
      ;;
    --lint)
      shift
      srpm_lint "$@"
      ;;
    --clean)
      shift
      srpm_clean "$@"
      ;;
    --done)
      shift
      srpm_done "$@"
      ;;
    *) error "$FUNCNAME: unknown command: $1" ;;
  esac
}

##
# srpm_init
#
# Implements `srpm --init`.
function srpm_init() {
  local W

  [ $PKM_DEBUG -ne 0 ] && set -x
  isset --vars PKG_NAME INIPKG_DIR
  W=$(srpm_show workdir)
  ensure_dir "$W"
  (
    cd "$W" &&
    git init &&
    echo '*.bz2' > .gitignore &&
    echo '*.gz' >> .gitignore &&
    echo '*.tar' >> .gitignore &&
    echo '*.tgz' >> .gitignore &&
    echo '*.xz' >> .gitignore &&
    git add .gitignore
  ) || error "$FUNCNAME: failed"
}

##
# srpm_show $1
#
#   $1 - what to be shown
#
# Implements `srpm --show`.
function srpm_show() {
  local W

  case $1 in
    srcdir)
      echo ${PKM_PRJROOT}/specfiles/${ProjectVars[PKG_NAME]}-init
      ;;
    destdir)
      echo ${ProjectVars[INIPKG_DIR]}/${ProjectVars[PKG_NAME]}
      ;;
    workdir)
      W="${ProjectVars[TMP_WORKPLACE]}"
      [ "$W" ] || W="${PKM_PRJROOT}/.${PKM_NAME}/tmp"
      echo $W/srpm/${ProjectVars[PKG_NAME]}
      ;;
  esac
}

##
# srpm_copyin $1
#
#   $1 - path to file to be copyied in
#
# Implements `srpm --copyin`.
function srpm_copyin() {
  local D
  local F

  [ $PKM_DEBUG -ne 0 ] && set -x
  D=$(srpm_show workdir)
  F="$1"
  [ -f "$F" ] || error "$FUNCNAME: $F is not a file"
  cp "$F" "$D/${F##*/}" || error "$FUNCNAME: can't copy $F"
  (cd "$D" && git add "${F##*/}") || error "$FUNCNAME: can't track ${F##*/}"
}

##
# srpm_copyout $1
#
#   $1 - path to destination
#
# Implements `srpm --copyout`.
function srpm_copyout() {
  local D
  local F

  [ $PKM_DEBUG -ne 0 ] && set -x
  D=$(srpm_show workdir)
  F="$1"
  [ -f "$D/${F##*/}" ] || error "$FUNCNAME: $D/${F##*/} is not a file"
  cp "$D/${F##*/}" "$F" || error "$FUNCNAME: can't copy $D/${F##*/}"
}

##
# srpm_commit
#
# Implements `srpm --commit`.
function srpm_commit() {
  local E
  local W

  [ $PKM_DEBUG -ne 0 ] && set -x
  W=$(srpm_show workdir)
  (
    cd "$W" &&
    { git log -1 2>&1 >/dev/null; E=$?; } &&
    if [ $E -ne 0 ]; then
      git commit -m "Initial commit"
    else
      git commit -m "Update"
    fi
  ) || error "$FUNCNAME: failed"
}

##
# srpm_get_sources
#
# Implements `srpm --get-sources`.
function srpm_get_sources() {
  local W

  [ $PKM_DEBUG -ne 0 ] && set -x
  W=$(srpm_show workdir)
  (
    cd "$W" &&
    spectool -g "${ProjectVars[PKG_NAME]}.spec"
  ) || error "$FUNCNAME: failed"
}

##
# srpm_srpm $1
#
#   $1 - release (optional)
#
# Implements `srpm --srpm`.
function srpm_srpm() {
  local R
  local V
  local W

  [ $PKM_DEBUG -ne 0 ] && { V=-v; set -x; }
  W=$(srpm_show workdir)
  R="$1"; [ "$R" ] || R="master"
  (
    cd "$W" &&
    fedpkg $V --release "$R" local
  ) || error "$FUNCNAME: failed"
}

##
# srpm_lint
#
# Implements `srpm --lint'.
function srpm_lint() {
  [ $PKM_DEBUG -ne 0 ] && set -x
  do_rpmlint --workdir "$(srpm_show workdir)" \
             --specname "${ProjectVars[PKG_NAME]}" \
             --with-logging
}

##
# srpm_clean
#
# Implements `srpm --clean`.
function srpm_clean() {
  local T
  local W

  [ $PKM_DEBUG -ne 0 ] && set -x
  W=$(srpm_show workdir)
  T=5
  (
    cd "$W" &&
    while [ $(git status -s | grep -E '^\?\?' | wc -l) -gt 0 ] && [ $T -gt 0 ]; do
      fedpkg clean
      sleep 1
      T=$(( T - 1 ))
    done
  ) || error "$FUNCNAME: failed"
  (cd "$W" && [ $(git status -s | grep -E '^\?\?' | wc -l) -gt 0 ]) \
  && error "$FUNCNAME: there are still untracked files" || :
}

##
# srpm_done
#
# Implements `srpm --done`.
function srpm_done() {
  local W

  [ $PKM_DEBUG -ne 0 ] && set -x
  W=$(srpm_show workdir)
  [ -d "$W" ] && rm -rfd "$W"
  [ -d "$W" ] && error "$FUNCNAME: failed" || :
}

##
# inipkg $1 $2 ... $n
#
#   $1, $2, ..., $n - list of releases
#
# Make an initial package (suitable for review requests).
function inipkg() {
  local R

  isset --vars PKG_NAME INIPKG_DIR
  assert_dir $(srpm_show srcdir)
  ensure_dir $(srpm_show destdir)

  [ $# -gt 0 ] || set -- master

  [ $PKM_DEBUG -ne 0 ] && set -x

  # Copy files:
  for_files inipkg inipkg_cp_file

  # Create source rpms:
  # - wipe out old
  srpm --done
  # - fresh init
  sleep 1
  srpm --init
  # - move package files inside
  for_files inipkg inipkg_copyin
  # - get sources
  srpm --get-sources
  # - commit changes to internal git repo
  srpm --commit
  # - make srpms
  for R; do
    srpm --srpm $R
    sleep 1
    srpm --lint
    inipkg_copyout
    srpm --clean
    sleep 1
  done
  # - done
  srpm --done
}

##
# inipkg_cp_file $1
#
#   $1 - path to file
#
# Helper for `inipkg'.
function inipkg_cp_file() {
  local D
  local F

  D=$(srpm_show destdir)
  F="${PKM_PRJROOT}/$1"
  [ -f "$F" ] || error "$FUNCNAME: $F is not a file"
  cp "$F" "$D/${F##*/}" || error "can't copy $F to $D/${F##*/}"
}

##
# inipkg_copyin $1
#
#   $1 - path to file
#
# Helper for `inipkg'.
function inipkg_copyin() {
  srpm --copyin "${PKM_PRJROOT}/$1"
}

##
# inipkg_copyout
#
# Helper for `inipkg'.
function inipkg_copyout() {
  local D
  local W

  D=$(srpm_show destdir)
  W=$(srpm_show workdir)
  for F in $(ls -a1 $W); do
    if [[ "$F" =~ ^.*\.src\.rpm$ ]]; then
      srpm --copyout "$D/$F"
    fi
  done
}

##
# gopkg_meta $1 $2 ... $n
#
#   $1, $2, ..., $n - options
#
# where options are
#
#   --provider-re <pattern>    set the pattern that matches provider
#   --project-re <pattern>     set the pattern that matches project
#   --srcdir <path>            set the path to where the package sources
#                              should be copied (relative to golang workspace)
#   --upstream <url>           URL to project's upstream
#
# Compute project variables associated with golang package. These variables
# are:
#
#   PKG_SHORTCOMMIT
#     - computed from PKG_COMMIT
#   GOPKG_PROVIDER
#   GOPKG_PROVIDER_TLD
#   GOPKG_PROJECT
#   GOPKG_REPO
#     - computed from package name or, if given, from --srcdir option
#   GOPKG_SRCDIR
#     - given by --srcdir option; if no --srcdir option is provided,
#       GOPKG_SRCDIR is computed from GOPKG_PROVIDER, GOPKG_PROVIDER_TLD,
#       GOPKG_PROJECT, and GOPKG_REPO
#   UPSTREAM_REPO
#     - given by --upstream option; if no --upstream option is provided,
#       UPSTREAM_REPO is computed from GOPKG_PROVIDER, GOPKG_PROVIDER_TLD,
#       GOPKG_PROJECT, and GOPKG_REPO
#
# As a pattern can be used a bash regular expression, without anchors and
# parenthesis. The occurrence of \w is substituted by [_0-9A-Za-z].
#
# Examples:
#
#   # set source directory to 'github.com/paulrosania/go-charset'; that is,
#   # package source files will be copied to
#   #
#   #   $GOWORKSPACE/src/github.com/paulrosania/go-charset
#   #
#   gopkg_meta --srcdir github.com/paulrosania/go-charset
#
#   # set the patterns that match provider and project to \w and \w-\w,
#   # respectively; these patterns are used during guessing the provider,
#   # project, and repo from the package name, i.e. if the package name is
#   #
#   #   golang-github-foo-bar-baz
#   #
#   # then the provider's and project's name is github and foo-bar,
#   # respectively
#   gopkg_meta --provider-re '\w' --project-re '\w-\w'
#
#   # set the project's upstream URL
#   gopkg_meta --upstream 'https://github.com/paulrosania/go-charset.git'
#
function gopkg_meta() {
  local PROVIDER
  local PROVIDER_TLD
  local PROJECT
  local REPO
  local SCANNER
  local T
  local U

  # Gather options:
  local OPT_PROVIDER_RE
  local OPT_PROJECT_RE
  local OPT_SRCDIR
  local OPT_UPSTREAM
  while [ $# -gt 0 ]; do
    case $1 in
      --provider-re)
        OPT_PROVIDER_RE="$2"
        shift 2
        ;;
      --project-re)
        OPT_PROJECT_RE="$2"
        shift 2
        ;;
      --srcdir)
        OPT_SRCDIR="$2"
        shift 2
        ;;
      --upstream)
        OPT_UPSTREAM="$2"
        shift 2
        ;;
      *) error "$FUNCNAME: invalid option: $1" ;;
    esac
  done
  # Set default values:
  [ -z "$OPT_PROVIDER_RE" ] && OPT_PROVIDER_RE='\w'
  [ -z "$OPT_PROJECT_RE" ] && OPT_PROJECT_RE='\w'
  # Assemble scanner:
  SCANNER="^xgolang-"
  T=$(echo "(${OPT_PROVIDER_RE})" | sed -e 's/\\w/[_0-9A-Za-z]+/g')
  SCANNER="${SCANNER}${T}-"
  T=$(echo "(${OPT_PROJECT_RE})" | sed -e 's/\\w/[_0-9A-Za-z]+/g')
  SCANNER="${SCANNER}${T}-(.+)$"
  # Guess PROVIDER, PROVIDER_TLD, PROJECT, and REPO:
  if [[ "x$OPT_SRCDIR" =~ ^x([^/.]+)\.([^/]+)/([^/]+)/([^/]+)$ ]]; then
    # - from `--srcdir':
    PROVIDER="${BASH_REMATCH[1]}"
    PROVIDER_TLD="${BASH_REMATCH[2]}"
    PROJECT="${BASH_REMATCH[3]}"
    REPO="${BASH_REMATCH[4]}"
  elif [[ "x$OPT_UPSTREAM" =~ ^x[^/]+//([^/.]+)\.([^/]+)/([^/]+)/([^/.]+).*$ ]]; then
    # - from `--upstream':
    PROVIDER="${BASH_REMATCH[1]}"
    PROVIDER_TLD="${BASH_REMATCH[2]}"
    PROJECT="${BASH_REMATCH[3]}"
    REPO="${BASH_REMATCH[4]}"
  elif [[ "x${ProjectVars[PKG_NAME]}" =~ $SCANNER ]]; then
    # - from package name:
    PROVIDER="${BASH_REMATCH[1]}"
    PROJECT="${BASH_REMATCH[2]}"
    REPO="${BASH_REMATCH[3]}"
    case x$PROVIDER in
      xgithub) PROVIDER_TLD=com ;;
      x*) error "$FUNCNAME: cannot determine PROVIDER_TLD from '$PROVIDER'" ;;
    esac
  else
    error "$FUNCNAME: cannot determine PROVIDER, PROVIDER_TLD, PROJECT, and REPO"
  fi
  # Finally, set up project variables:
  # - PKG_SHORTCOMMIT
  [ ${#ProjectVars[PKG_COMMIT]} -eq 40 ] || error "$FUNCNAME: #PKG_COMMIT != 40"
  setvar PKG_SHORTCOMMIT "${ProjectVars[PKG_COMMIT]:0:7}"
  # - GOPKG_PROVIDER, GOPKG_PROVIDER_TLD, GOPKG_PROJECT, GOPKG_REPO
  setvar GOPKG_PROVIDER "${PROVIDER}"
  setvar GOPKG_PROVIDER_TLD "${PROVIDER_TLD}"
  setvar GOPKG_PROJECT "${PROJECT}"
  setvar GOPKG_REPO "${REPO}"
  # - GOPKG_SRCDIR
  isset --vars GOWORKSPACE
  if [ "$OPT_SRCDIR" ]; then
    setvar GOPKG_SRCDIR "${ProjectVars[GOWORKSPACE]}/src/${OPT_SRCDIR}"
  else
    setvar GOPKG_SRCDIR "${ProjectVars[GOWORKSPACE]}/src/${PROVIDER}.${PROVIDER_TLD}/${PROJECT}/${REPO}"
  fi
  # - UPSTREAM_REPO
  if [ "$OPT_UPSTREAM" ]; then
    setvar UPSTREAM_REPO "${OPT_UPSTREAM}"
  else
    # Guess protocol:
    case $PROVIDER in
      github) T="https://"; U=".git" ;;
      *) error "$FUNCNAME: cannot determine protocol for $PROVIDER" ;;
    esac
    setvar UPSTREAM_REPO "${T}${PROVIDER}.${PROVIDER_TLD}/${PROJECT}/${REPO}${U}"
  fi
  # In debug mode, show the variables:
  [ $PKM_DEBUG -ne 0 ] && {
    echo "PKG_SHORTCOMMIT:     ${ProjectVars[PKG_SHORTCOMMIT]}"
    echo "GOPKG_PROVIDER:      ${ProjectVars[GOPKG_PROVIDER]}"
    echo "GOPKG_PROVIDER_TLD:  ${ProjectVars[GOPKG_PROVIDER_TLD]}"
    echo "GOPKG_PROJECT:       ${ProjectVars[GOPKG_PROJECT]}"
    echo "GOPKG_REPO:          ${ProjectVars[GOPKG_REPO]}"
    echo "GOPKG_SRCDIR:        ${ProjectVars[GOPKG_SRCDIR]}"
    echo "UPSTREAM_REPO:       ${ProjectVars[UPSTREAM_REPO]}"
  }
}
